#!/bin/bash
#
# ~/.bash_prompt

#######################################
# Prints Git branch name and status.
# Arguments:
#   Characters to quote.
# Outputs:
#   Writes Git branch name and status to stdout.
#######################################
prompt_git() {
  local branch_name=''
  local status=''

  # Check if the current directory is in a Git repository.
  if [[ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" == 'true' ]]; then
    # Check if the current directory is not in `.git`.
    if [[ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]]; then
      # Ensure index is up to date.
      git update-index --really-refresh -q &> /dev/null
      # Check for uncommitted changes.
      if ! git diff --quiet --ignore-submodules --cached; then
        status="${status}+"
      fi
      # Check for unstaged changes.
      if ! git diff-files --quiet --ignore-submodules --; then
        status="${status}!"
      fi
      # Check for untracked files.
      if [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
        status="${status}?"
      fi
      # Check for stashed files.
      if git rev-parse --verify refs/stash &> /dev/null; then
        status="${status}$"
      fi
    fi

    # Get the short symbolic ref.
    # If HEAD is not a symbolic ref, get the short SHA. Otherwise do nothing.
    branch_name="$(git symbolic-ref --quiet --short HEAD 2> /dev/null \
                    || git rev-parse --short HEAD 2> /dev/null \
                    || printf '(unknown)')"

    if [[ -n "${status}" ]]; then
      status=" ${status}"
    fi

    printf '%s' "${1}${branch_name}${status}${2}"
  fi
}

#######################################
# Sets Bash prompt.
# shellcheck disable=2034
#######################################
set_prompts() {
  local black='\[\033[1;30m\]'
  local red='\[\033[1;31m\]'
  local green='\[\033[1;32m\]'
  local yellow='\[\033[1;33m\]'
  local blue='\[\033[1;34m\]'
  local purple='\[\033[1;35m\]'
  local cyan='\[\033[1;36m\]'
  local white='\[\033[1;37m\]'
  local reset='\[\033[0m\]'

  local name_color=''

  # Check if user is logged in as root.
  if [[ "${EUID}" -eq 0 ]]; then
    name_color="${red}"
  else
    name_color="${green}"
  fi

  # Set the terminal title.
  # user@hostname: ~
  PS1='\[\033]0;\u@\h: \w\007\]'

  # Set the prompt.
  # user@hostname: ~ [master +!?$]
  # $
  # >
  PS1+=$'\n'
  PS1+="${name_color}\u@\h"
  PS1+="${black}: "
  PS1+="${blue}\w"
  PS1+="\$(prompt_git ' ${purple}[' ']')"
  PS1+=$'\n'
  PS1+="${black}\\$ "
  PS1+="${reset}"

  PS2="${black}> "
  PS2+="${reset}"

  export PS1
  export PS2
}

set_prompts
unset -f set_prompts
