#!/bin/bash
#
# ~/.bashrc

# If not running interactively, don't do anything.
case $- in
  *i*) ;;
  *) return ;;
esac

# ------------------------------------------------------------------------------
# Options
# ------------------------------------------------------------------------------

# Make `cd` builtin accept a variable name as an argument.
shopt -s cdable_vars

# Make `cd` builtin correct minor spelling errors.
shopt -s cdspell

# Check if a hashed command exists before trying to execute it.
shopt -s checkhash

# Check and update the window size after each command.
shopt -s checkwinsize

# Save all lines of a multiple-line command in the same history entry.
shopt -s cmdhist

# Append the history list to file instead of overwriting.
shopt -s histappend

# Allow user to edit a history substitution.
shopt -s histreedit

# Allow user to review a history substitution result.
shopt -s histverify

# Enable case-insensitive filename matching and completion.
shopt -s nocaseglob

# Disable completion on an empty line.
shopt -s no_empty_cmd_completion

# Make `less` more friendly for non-text input files.
if [[ -x /usr/bin/lesspipe ]]; then
  eval "$(SHELL=/bin/sh lesspipe)"
fi

# ------------------------------------------------------------------------------
# Exports
# ------------------------------------------------------------------------------

# Set the default language to English.
export LANG='en_US.UTF-8'

# Set the default collation order as in C.
export LC_COLLATE='C'

# Set the default editor to Vim.
export EDITOR='vim'

# Set the maximum number of lines to save in the history file.
export HISTFILESIZE=1000

# Set the maximum number of lines to remember in the command history.
export HISTSIZE=1000

# Disable saving lines that begin with a space or match the last history line to
# the history list.
export HISTCONTROL='ignoreboth'

# Disable saving the following commands to the history list.
export HISTIGNORE='&:bg:fg'

# Enable time stamp for `history` builtin.
export HISTTIMEFORMAT='%F %T '

# Set the number of trailing directory components to retain in prompt.
export PROMPT_DIRTRIM=3

# Make new shells get the history list from all previous shells.
if [[ ! "${PROMPT_COMMAND}" =~ 'history -a;' ]]; then
  export PROMPT_COMMAND="history -a; ${PROMPT_COMMAND}"
fi

# Enable 256 color terminal.
if [[ "${COLORTERM}" == gnome-* && "${TERM}" == xterm ]] \
  && infocmp gnome-256color &> /dev/null; then
  export TERM='gnome-256color'
elif infocmp xterm-256color &> /dev/null; then
  export TERM='xterm-256color'
fi

# ------------------------------------------------------------------------------
# Path
# ------------------------------------------------------------------------------

#
# Tests whether a directory can be added to `PATH`.
#
test_path() {
  [[ -d "${1}" && ":${PATH}:" != *":${1}:"* ]]
}

#
# Sets the `PATH` environment variable.
#
set_path() {
  # Define the directories to be prepended to `PATH`.
  local -a prepend_dirs=(
    /usr/local/bin
  )

  # Define the directories to be appended to `PATH`.
  local -a append_dirs=(
    /usr/bin
    "${HOME}/bin"
    "${HOME}/.local/bin"
  )

  # Prepend directories to `PATH`.
  for index in ${!prepend_dirs[*]}; do
    if test_path "${prepend_dirs[$index]}"; then
      PATH="${prepend_dirs[$index]}:${PATH}"
    fi
  done

  # Append directories to `PATH`.
  for index in ${!append_dirs[*]}; do
    if test_path "${append_dirs[$index]}"; then
      PATH="${PATH}:${append_dirs[$index]}"
    fi
  done

  export PATH
}

set_path
unset -f test_path
unset -f set_path

# ------------------------------------------------------------------------------
# Prompt
# ------------------------------------------------------------------------------

#
# Prints Git branch name and working tree status for prompt.
#
prompt_git() {
  local branch=''
  local status=''

  # Do nothing if the current directory is not a Git repository.
  if [[ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" != 'true' ]]; then
    return
  fi
  # Do nothing if the current directory is inside `.git`.
  if [[ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'true' ]]; then
    return
  fi

  # Check for uncommitted changes.
  if ! git diff --quiet --ignore-submodules --cached; then
    status="${status}+"
  fi
  # Check for unstaged changes.
  if ! git diff-files --quiet --ignore-submodules --; then
    status="${status}!"
  fi
  # Check for untracked files.
  if [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
    status="${status}?"
  fi
  # Check for stashed files.
  if git rev-parse --verify refs/stash &> /dev/null; then
    status="${status}$"
  fi

  if [[ -n "${status}" ]]; then
    status=" ${status}"
  fi

  # Get the branch name or short commit SHA.
  branch="$(printf '%s' "$(git rev-parse --abbrev-ref HEAD 2> /dev/null \
    || git rev-parse --short HEAD 2> /dev/null \
    || printf ' (unknown)')" | \
    tr -d '\n')"

  printf '%s' "${1}${branch}${status}${2}"
}

#
# Sets the prompt statement variables.
# shellcheck disable=SC2034
#
set_prompts() {
  local reset='\[\033[0m\]'
  local gray='\[\033[1;30m\]'
  local red='\[\033[1;31m\]'
  local green='\[\033[1;32m\]'
  local yellow='\[\033[1;33m\]'
  local blue='\[\033[1;34m\]'
  local purple='\[\033[1;35m\]'
  local cyan='\[\033[1;36m\]'
  local white='\[\033[1;37m\]'

  # Set the terminal title.
  #   user@hostname: ~
  PS1='\[\033]0;\u@\h: \w\007\]'

  # Set the default interactive prompt.
  #   user@hostname: ~ [master +!?$]
  #   $ ...
  PS1+=$'\n'
  PS1+="${green}\u@\h"
  PS1+="${gray}: "
  PS1+="${blue}\w"
  PS1+="\$(prompt_git ' ${purple}[' ']')"
  PS1+=$'\n'
  PS1+="${gray}\\$ "
  PS1+="${reset}"

  # Set the continuation interactive prompt.
  #   > ...
  PS2="${gray}> "
  PS2+="${reset}"

  export PS1
  export PS2
}

set_prompts
unset -f set_prompts

# ------------------------------------------------------------------------------
# Aliases
# ------------------------------------------------------------------------------

# Enable color support.
if [[ -x /usr/bin/dircolors ]]; then
  if [[ -r "${HOME}/.dircolors" ]]; then
    eval "$(dircolors -b "${HOME}/.dircolors")"
  else
    eval "$(dircolors -b)"
  fi
  alias ls='ls --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
fi

# Load `.bash_aliases` if it exists.
if [[ -f "${HOME}/.bash_aliases" ]]; then
  source "${HOME}/.bash_aliases"
fi

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------

# Load `.bash_functions` if it exists.
if [[ -f "${HOME}/.bash_functions" ]]; then
  source "${HOME}/.bash_functions"
fi

# ------------------------------------------------------------------------------
# Completion
# ------------------------------------------------------------------------------

# Enable programmable completion features.
if [[ -f /usr/share/bash-completion/bash_completion ]]; then
  source /usr/share/bash-completion/bash_completion
elif [[ -f /etc/bash_completion ]]; then
  source /etc/bash_completion
fi

# ------------------------------------------------------------------------------
# Local Configuration
# ------------------------------------------------------------------------------

# Load `.bashrc.local` if it exists.
if [[ -f "${HOME}/.bashrc.local" ]]; then
  source "${HOME}/.bashrc.local"
fi
