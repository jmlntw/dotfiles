#!/bin/bash
#
# Installs or synchronizes dotfiles.

set -o errexit
set -o errtrace
set -o nounset

# N.B. If you want to fork this repository and maintain your own dotfiles, you
# must substitute the following variables for your own.
DOTFILES_GIT_URL=${DOTFILES_GIT_URL:-'https://github.com/jmlntw/dotfiles.git'}
DOTFILES_TAR_URL=${DOTFILES_TAR_URL:-'https://github.com/jmlntw/dotfiles/tarball/master'}

DOTFILES_PATH=${DOTFILES_PATH:-"${HOME}/.dotfiles"}

#######################################
# Prints help message.
#######################################
run_help() {
cat <<EOS
Installs or synchronizes dotfiles.

Usage: ${0##*/} [options]

Options:
  -h, --help    Print this help message.
  --no-sync     Suppress pulling from the remote repository.
EOS
}

#######################################
# Installs dotfiles.
#######################################
install_dotfiles() {
  e_header '=> Installing...'

  deploy link 'bash'
  deploy link 'shell'
  deploy link 'git'
  deploy link 'bin'                   '.local/bin'
  deploy link 'vim/.vimrc'            '.vimrc'
  deploy link 'vim/.vim'              '.vim'
  deploy link 'fontconfig'            '.config/fontconfig/conf.d'
  deploy copy 'firefox'               '.mozilla/firefox'
  deploy link 'firefox/default'       '.mozilla/firefox/default'
  deploy link 'atom'                  '.atom'
  deploy link 'vscode/User'           '.config/Code/User'
  deploy copy 'vscode/Local Storage'  '.config/Code/Local Storage'

  e_success 'Done.'
}

#######################################
# Downloads dotfiles from the remote
# repository.
#######################################
download_dotfiles() {
  e_header '=> Downloading...'

  if command_exists 'git'; then
    git clone --depth 1 --recursive "${DOTFILES_GIT_URL}" "${DOTFILES_PATH}"
  elif command_exists 'curl' || command_exists 'wget'; then
    if command_exists 'curl'; then
      curl -L -o "${HOME}/dotfiles.tar.gz" "${DOTFILES_TAR_URL}"
    elif command_exists 'wget'; then
      wget -O "${HOME}/dotfiles.tar.gz" "${DOTFILES_TAR_URL}"
    fi
    mkdir -p "${DOTFILES_PATH}"
    tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_PATH}"
    rm -rf "${HOME}/dotfiles.tar.gz"
  else
    die 'Either Git, cURL or Wget is required.'
  fi

  e_success 'Done.'
}

#######################################
# Synchronizes dotfiles with the remote
# repository.
#######################################
sync_dotfiles() {
  e_header '=> Synchronizing...'

  if ! command_exists 'git'; then
    e_warning 'Git is not installed. Skipped synchronization.'
    return 0
  fi

  cd "${DOTFILES_PATH}"

  if ! is_git_repo; then
    git init
    git remote add origin "${DOTFILES_GIT_URL}"
    git fetch origin master
    git reset --hard FETCH_HEAD
    git clean -fd
  fi

  git pull --rebase origin master
  git submodule update --recursive --init --quiet

  e_success 'Done.'
}

#######################################
# Delpoys a file or all files one level
# deep from the specified directory to
# home directory.
#######################################
deploy() {
  local method="${1:-link}"
  local source="${DOTFILES_PATH}/${2:-}"
  local dest="${HOME}/${3:-}"
  local deploy_func

  case "${method}" in
    link) deploy_func=link_file ;;
    copy) deploy_func=copy_file ;;
  esac

  if [[ -f "${source}" ]]; then
    $deploy_func "${source}" "${dest%/}"
  elif [[ -d "${source}" ]]; then
    find "${source}" -maxdepth 1 -type f -print0 \
      | sort -z \
      | while IFS= read -r -d $'\0' file; do
          $deploy_func "${file}" "${dest%/}/${file##*/}"
        done
  else
    die "Invalid source: ${source}"
  fi
}

#######################################
# Creates a backup if the specified
# file exists.
#######################################
backup_file() {
  if [[ -f "${1}" ]] && [[ ! -L "${1}" ]]; then
    mv "${1}" "${1}~"
  fi
}

#######################################
# Creates a symbolic link.
#######################################
link_file() {
  backup_file "${2}" \
    && mkdir -p "${2%/*}" \
    && ln -fs "${1}" "${2}" \
    && printf '\033[1;30m%s:\033[0m %s \033[1;30m->\033[0m ~/%s\n' \
      'ln' "${1#${DOTFILES_PATH}/}" "${2#${HOME}/}"
}

#######################################
# Copies a file.
#######################################
copy_file() {
  backup_file "${2}" \
    && mkdir -p "${2%/*}" \
    && cp -f "${1}" "${2}" \
    && printf '\033[1;30m%s:\033[0m %s \033[1;30m->\033[0m ~/%s\n' \
      'cp' "${1#${DOTFILES_PATH}/}" "${2#${HOME}/}"
}

#######################################
# Tests whether we are in a Git
# repository.
#######################################
is_git_repo() {
  git rev-parse --is-inside-work-tree &>/dev/null
}

#######################################
# Tests whether a command exists.
#######################################
command_exists() {
  command -v "$@" >/dev/null 2>&1
}

#######################################
# Exits this script with a failure
# message and returns an exit code.
#######################################
die() {
  e_failure "Terminated: ${1}" 1>&2
  exit "${2:-1}"
}

#######################################
# Prints a header message.
#######################################
e_header() {
  printf '\033[1;37m%s\033[0m\n' "$@"
}

#######################################
# Prints a success message.
#######################################
e_success() {
  printf '\033[0;32m%s %s\033[0m\n' '✔' "$@"
}

#######################################
# Prints a failure message.
#######################################
e_failure() {
  printf '\033[0;31m%s %s\033[0m\n' '✘' "$@"
}

#######################################
# Prints a warning message.
#######################################
e_warning() {
  printf '\033[0;33m%s %s\033[0m\n' '!' "$@"
}

#######################################
# Starts this script.
#######################################
main() {
  trap 'die "There was an error at line ${LINENO}."' ERR

  local opt_sync=true

  # Test for all known options.
  for opt in "$@"; do
    case "${opt}" in
      -h|--help) run_help; exit ;;
      --no-sync) opt_sync=false ;;
      -*|--*) e_warning "Invalid option: ${opt}" ;;
    esac
  done

  if [[ ! -d "${DOTFILES_PATH}" ]]; then
    download_dotfiles
    opt_sync=false
  fi

  if $opt_sync; then
    sync_dotfiles
  fi

  install_dotfiles

  # Restart the shell automatically.
  if [[ -n "${BASH_EXECUTION_STRING:-}" ]] || [[ -p /dev/stdin ]]; then
    if [[ -p /dev/stdin ]]; then
      e_warning 'Restart the shell before you continue.'
    else
      exec "${SHELL:-'/bin/bash'}"
    fi
  fi
}

main "$@"
