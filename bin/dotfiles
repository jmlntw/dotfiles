#!/bin/bash
#
# Installs or synchronizes dotfiles.

set -o errexit
set -o errtrace
set -o nounset

# N.B. If you want to fork this repository and maintain your own dotfiles, you
# must substitute the following variables for your own.
DOTFILES_GIT_URL=${DOTFILES_GIT_URL:-'https://github.com/jmlntw/dotfiles.git'}
DOTFILES_TAR_URL=${DOTFILES_TAR_URL:-'https://github.com/jmlntw/dotfiles/tarball/master'}

DOTFILES_PATH=${DOTFILES_PATH:-"${HOME}/.dotfiles"}

#######################################
# Prints help message.
#######################################
run_help() {
cat <<EOS
Installs or synchronizes dotfiles.

Usage: ${0##*/} [options]

Options:
  -h, --help    Print this help message.
  --no-sync     Suppress pulling from the remote repository.
EOS
}

#######################################
# Installs dotfiles.
#######################################
install_dotfiles() {
  e_header '=> Installing...'

  deploy link 'bin'                   '.local/bin'
  deploy link 'shell'
  deploy link 'bash'
  deploy link 'git'
  deploy link 'vim'
  deploy link 'fontconfig'            '.config/fontconfig/conf.d'
  deploy copy 'firefox/profiles.ini'  '.mozilla/firefox/profiles.ini'
  deploy link 'firefox/default'       '.mozilla/firefox/default'
  deploy link 'atom'                  '.atom'
  deploy link 'vscode/User'           '.config/Code/User'
  deploy copy 'vscode/Local Storage'  '.config/Code/Local Storage'
}

#######################################
# Downloads dotfiles from the remote
# repository.
#######################################
download_dotfiles() {
  e_header '=> Downloading...'

  if command_exists 'git'; then
    git clone --depth 1 --recursive "${DOTFILES_GIT_URL}" "${DOTFILES_PATH}"
  elif command_exists 'curl' || command_exists 'wget'; then
    if command_exists 'curl'; then
      curl -L -o "${HOME}/dotfiles.tar.gz" "${DOTFILES_TAR_URL}"
    elif command_exists 'wget'; then
      wget -O "${HOME}/dotfiles.tar.gz" "${DOTFILES_TAR_URL}"
    fi
    mkdir -p "${DOTFILES_PATH}"
    tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_PATH}"
    rm -rf "${HOME}/dotfiles.tar.gz"
  else
    die 'Either Git, cURL or Wget is required.'
  fi
}

#######################################
# Synchronizes dotfiles with the remote
# repository.
#######################################
sync_dotfiles() {
  e_header '=> Synchronizing...'

  if ! command_exists 'git'; then
    e_warning 'Git is not installed. Skipped synchronization.'
    return 0
  fi

  cd "${DOTFILES_PATH}"

  if ! is_git_repo; then
    git init
    git remote add origin "${DOTFILES_GIT_URL}"
    git fetch origin master
    git reset --hard FETCH_HEAD
    git clean -fd
  fi

  git pull --rebase origin master
  git submodule update --recursive --init --quiet
}

#######################################
# Deploys files from dotfiles to home
# directory.
#######################################
deploy() {
  local source="${DOTFILES_PATH}/${2:-}"
  local dest="${HOME}/${3:-}"
  local deploy_cmd

  case "${1:-link}" in
    link) deploy_cmd=link_file ;;
    copy) deploy_cmd=copy_file ;;
  esac

  if [[ -f "${source}" ]]; then
    $deploy_cmd "${source}" "${dest%/}"
  elif [[ -d "${source}" ]]; then
    get_files "${source}" | while IFS= read -r -d $'\0' file; do
      $deploy_cmd "${file}" "${dest%/}/${file##${source}/}"
    done
  else
    die "Invalid source: ${source}"
  fi
}

#######################################
# Gets a list of all files in the
# specified directory.
#######################################
get_files() {
  find "${1}" -type f -print0 | sort -z
}

#######################################
# Creates a backup if the specified
# file exists.
#######################################
backup_file() {
  if [[ -f "${1}" ]] && [[ ! -L "${1}" ]]; then
    mv "${1}" "${1}~"
  fi
}

#######################################
# Creates a symbolic link.
#######################################
link_file() {
  backup_file "${2}"
  mkdir -p "${2%/*}"
  ln -fs "${1}" "${2}"

  e_success "Linked: ~/${2##${HOME}/}"
}

#######################################
# Copies a file.
#######################################
copy_file() {
  backup_file "${2}"
  mkdir -p "${2%/*}"
  cp -f "${1}" "${2}"

  e_success "Copied: ~/${2##${HOME}/}"
}

#######################################
# Tests whether we are in a Git
# repository.
#######################################
is_git_repo() {
  git rev-parse --is-inside-work-tree &>/dev/null
}

#######################################
# Tests whether a command exists.
#######################################
command_exists() {
  command -v "$@" >/dev/null 2>&1
}

#######################################
# Exits this script with a failure
# message and returns an exit code.
#######################################
die() {
  e_failure "Terminated: ${1}" 1>&2
  exit "${2:-1}"
}

#######################################
# Prints a header message.
#######################################
e_header() {
  printf '\033[1;37m%s\033[0m\n' "$@"
}

#######################################
# Prints a success message.
#######################################
e_success() {
  printf '\033[0;32m%s %s\033[0m\n' '✔' "$@"
}

#######################################
# Prints a failure message.
#######################################
e_failure() {
  printf '\033[0;31m%s %s\033[0m\n' '✘' "$@"
}

#######################################
# Prints a warning message.
#######################################
e_warning() {
  printf '\033[0;33m%s %s\033[0m\n' '!' "$@"
}

#######################################
# Starts this script.
#######################################
main() {
  trap 'die "There was an error at line ${LINENO}."' ERR

  local opt_sync=true

  # Test for all known options.
  for opt in "$@"; do
    case "${opt}" in
      -h|--help) run_help; exit ;;
      --no-sync) opt_sync=false ;;
    esac
  done

  if [[ ! -d "${DOTFILES_PATH}" ]]; then
    download_dotfiles
  elif $opt_sync; then
    sync_dotfiles
  fi

  install_dotfiles

  e_warning 'Restart the shell before you continue.'
}

main "$@"
